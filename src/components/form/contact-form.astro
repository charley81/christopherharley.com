---
import Input from './input.astro'
import Textarea from './textarea.astro'
import SectionTitle from '../section-title.astro'
import Section from '../section.astro'
---

<Section class="max-w-4xl">
  <SectionTitle text="Contact Me" />
  <div id="form-status" class="mt-2 h-8 font-medium"></div>
  <form
    data-netlify="true"
    id="contact-form"
    class="mx-auto mt-10"
    novalidate
    name="contact"
    autocomplete="off"
  >
    <input type="hidden" name="form-name" value="contact" />
    <Input
      label="Name"
      name="name"
      type="text"
      placeholder="Your name"
      required
    />
    <Input
      label="Email"
      name="email"
      type="email"
      placeholder="your.email@example.com"
      required
    />
    <Textarea
      label="Your message"
      name="message"
      placeholder="Type your message here"
      required
      rows={5}
    />
    <button
      type="submit"
      id="submit-button"
      class="mt-4 w-full rounded-(--border-radius) bg-dark px-6 py-3 font-bold text-light hover:bg-dark/80 focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:outline-none disabled:cursor-not-allowed disabled:bg-gray-500"
    >
      Send message
    </button>
  </form>
</Section>

<script>
  import { contactSchema } from '../../schemas/contact'

  function renderStatus(message: string, type: string) {
    const colorClasses =
      type === 'success'
        ? 'bg-green-50 text-green-600 border-green-200'
        : 'bg-red-50 text-red-600 border-red-200'

    return `
          <div class="p-4 rounded-md border ${colorClasses}" role="alert">
            <p class="text-sm font-medium">${message}</p>  
          </div>
        `
  }

  const form = document.querySelector('#contact-form') as HTMLFormElement

  form?.addEventListener('submit', async (e) => {
    e.preventDefault()

    const formData = new FormData(form)
    const data = Object.fromEntries(formData)

    const result = contactSchema.safeParse(data)

    document.querySelectorAll('[id$="-error"]').forEach((el) => {
      el.textContent = ''
      el.classList.add('invisible')
    })

    if (!result.success) {
      result.error.issues.forEach((issue) => {
        const errorSpan = document.querySelector(
          `#${String(issue.path[0])}-error`,
        )

        if (errorSpan) {
          errorSpan.textContent = issue.message
          errorSpan.classList.remove('invisible')
        }
      })

      return
    }

    const submitButton = document.querySelector(
      '#submit-button',
    ) as HTMLButtonElement

    const statusBox = document.querySelector('#form-status') as HTMLElement

    submitButton.disabled = true
    submitButton!.textContent = 'submitting'

    try {
      const response = await fetch('/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams(formData as any).toString(),
      })

      if (response.ok) {
        statusBox!.innerHTML = renderStatus('Success! Talk soon', 'success')
        form.reset()
      } else {
        throw new Error('Network response was not ok')
      }
    } catch (error) {
      statusBox!.innerHTML = renderStatus(
        'Something went wrong, please try again later',
        'error',
      )
    } finally {
      submitButton.disabled = false
      submitButton!.textContent = 'Send Message'
    }

    setTimeout(() => {
      if (statusBox) {
        statusBox.innerHTML = ''
      }
    }, 5000)
  })
</script>
